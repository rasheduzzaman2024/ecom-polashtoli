package com.polashtoli.service;

import com.polashtoli.model.Product;
import com.polashtoli.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional
public class ProductService {
    
    private final ProductRepository productRepository;
    
    // Get all products
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }
    
    // Get product by ID
    public Product getProductById(String id) {
        return productRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Product not found with ID: " + id));
    }
    
    // Get product by SKU
    public Product getProductBySku(String sku) {
        return productRepository.findBySku(sku)
                .orElseThrow(() -> new RuntimeException("Product not found with SKU: " + sku));
    }
    
    // Create product (ID auto-generated by database trigger)
    public Product createProduct(Product product) {
        // Validate SKU uniqueness
        if (product.getSku() != null && productRepository.findBySku(product.getSku()).isPresent()) {
            throw new RuntimeException("Product with SKU " + product.getSku() + " already exists");
        }
        
        // Set defaults
        if (product.getCreatedAt() == null) {
            product.setCreatedAt(LocalDate.now());
        }
        if (product.getStatus() == null) {
            product.setStatus("active");
        }
        
        return productRepository.save(product);
    }
    
    // Update product
    public Product updateProduct(String id, Product productDetails) {
        Product existingProduct = getProductById(id);
        
        // Update fields
        existingProduct.setName(productDetails.getName());
        existingProduct.setCategory(productDetails.getCategory());
        existingProduct.setPrice(productDetails.getPrice());
        existingProduct.setDiscount(productDetails.getDiscount());
        existingProduct.setStock(productDetails.getStock());
        existingProduct.setDescription(productDetails.getDescription());
        existingProduct.setImages(productDetails.getImages());
        existingProduct.setTags(productDetails.getTags());
        existingProduct.setFeatured(productDetails.getFeatured());
        existingProduct.setStatus(productDetails.getStatus());
        
        // Don't update SKU, ID, or createdAt
        
        return productRepository.save(existingProduct);
    }
    
    // Delete product
    public void deleteProduct(String id) {
        if (!productRepository.existsById(id)) {
            throw new RuntimeException("Product not found with ID: " + id);
        }
        productRepository.deleteById(id);
    }
    
    // Get products by category
    public List<Product> getProductsByCategory(String category) {
        return productRepository.findByCategory(category);
    }
    
    // Get featured products
    public List<Product> getFeaturedProducts() {
        return productRepository.findByFeaturedTrue();
    }
    
    // Search products
    public List<Product> searchProducts(String query) {
        return productRepository.search(query);
    }
    
    // Get products by stock status
    public List<Product> getProductsByStockStatus(String status) {
        return switch (status.toLowerCase()) {
            case "in-stock" -> productRepository.findByStockGreaterThan(10);
            case "low-stock" -> productRepository.findByStockBetween(1, 10);
            case "out-of-stock" -> productRepository.findByStockEquals(0);
            default -> productRepository.findAll();
        };
    }
    
    // Get products by date
    public List<Product> getProductsByDate(LocalDate date) {
        return productRepository.findByCreatedAt(date);
    }
    
    // Get products by date range
    public List<Product> getProductsByDateRange(LocalDate startDate, LocalDate endDate) {
        return productRepository.findByCreatedAtBetween(startDate, endDate);
    }
    
    // Update stock
    public Product updateStock(String id, Integer newStock) {
        Product product = getProductById(id);
        product.setStock(newStock);
        return productRepository.save(product);
    }
    
    // Statistics
    public Long getTotalCount() {
        return productRepository.count();
    }
    
    public Long getCountByCategory(String category) {
        return productRepository.countByCategory(category);
    }
    
    public Long getCountByStatus(String status) {
        return productRepository.countByStatus(status);
    }
    
    public Long getTodayCount() {
        return productRepository.countByCreatedAt(LocalDate.now());
    }
}
